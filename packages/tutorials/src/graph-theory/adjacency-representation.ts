import { Tutorial } from '../types';

export const adjacencyRepresentationTutorial: Tutorial = {
  id: 'adjacency-representation',
  title: '隣接行列と隣接リスト',
  description: 'グラフをコンピュータ上で表現する2つの主要な方法を学びます。',
  category: 'graph-theory',
  steps: [
    {
      id: 'hook',
      title: 'グラフをどう保存する？',
      content: '絵として描けるグラフを、コンピュータのメモリにどう保存すればよいでしょうか？\n\n主に2つの方法があります：隣接行列と隣接リストです。\n\n同じグラフが2つの異なる表現に変換される様子を見てみましょう。',
      sceneConfig: { showGrid: true, showAxes: true, cameraPosition: [0, 0, 5] },
      interactive: false,
      nextCondition: 'click',
      stepType: 'animation',
    },
    {
      id: 'touch',
      title: '表現方法を切り替えてみよう',
      content: 'グラフに辺を追加・削除して、隣接行列と隣接リストがどう変わるか観察しましょう。\n\n隣接行列は行列の要素が0/1で変化します。\n\n隣接リストは各頂点の隣接頂点リストが更新されます。',
      sceneConfig: { showGrid: true, showAxes: true, cameraPosition: [0, 0, 5] },
      interactive: true,
      nextCondition: 'interaction',
      stepType: 'interactive',
    },
    {
      id: 'example-1',
      title: '隣接行列',
      content: 'n頂点のグラフを n×n の行列 A で表します。\n\nA[i][j] = 1 ならば頂点iと頂点jの間に辺がある、0 ならない。\n\n無向グラフでは A は対称行列です。重み付きグラフでは 0/1 の代わりに重みを格納します。\n\nメモリ使用量：O(n²)',
      sceneConfig: { showGrid: true, showAxes: true, cameraPosition: [0, 0, 5] },
      interactive: false,
      nextCondition: 'click',
      stepType: 'explanation',
    },
    {
      id: 'example-2',
      title: '隣接リスト',
      content: '各頂点について、隣接する頂点のリストを保持します。\n\n例：頂点1 → [2, 3]、頂点2 → [1, 3]、頂点3 → [1, 2]\n\nスパース（辺が少ない）グラフでは隣接リストの方が効率的です。\n\nメモリ使用量：O(n + m)（mは辺の数）',
      sceneConfig: { showGrid: true, showAxes: true, cameraPosition: [0, 0, 5] },
      interactive: false,
      nextCondition: 'click',
      stepType: 'explanation',
    },
    {
      id: 'predict',
      title: '確認クイズ',
      content: 'クイズに答えましょう。',
      sceneConfig: { showGrid: true, showAxes: true, cameraPosition: [0, 0, 5] },
      interactive: false,
      nextCondition: 'click',
      stepType: 'quiz',
      quiz: {
        question: '1000頂点で辺が2000本のグラフを扱う場合、メモリ効率が良いのはどちらですか？',
        options: [
          { id: 'a', label: '隣接行列（O(n²) = O(1,000,000)）', correct: false },
          { id: 'b', label: '隣接リスト（O(n+m) = O(3,000)）', correct: true },
          { id: 'c', label: 'どちらも同じ', correct: false },
          { id: 'd', label: 'どちらも使えない', correct: false },
        ],
        explanation: 'スパースグラフ（辺が少ない）では隣接リストが効率的です。O(n+m)=O(3,000) は O(n²)=O(1,000,000) より遥かに小さいです。',
      },
    },
    {
      id: 'alternate',
      title: '用途による使い分け',
      content: '隣接行列の利点：\n- 辺の存在確認がO(1)\n- 行列演算でグラフ分析可能\n\n隣接リストの利点：\n- メモリ効率が良い（スパースグラフ）\n- 隣接頂点の列挙が高速\n\n密なグラフには隣接行列、疎なグラフには隣接リストが適しています。',
      sceneConfig: { showGrid: true, showAxes: true, cameraPosition: [0, 0, 5] },
      interactive: false,
      nextCondition: 'click',
      stepType: 'explanation',
    },
    {
      id: 'summary',
      title: 'まとめ',
      content: '今回学んだポイント：\n\n1. 隣接行列：n×n行列で辺の有無を表現（O(n²)メモリ）\n2. 隣接リスト：各頂点の隣接頂点を列挙（O(n+m)メモリ）\n3. グラフの密度に応じて適切な表現を選ぶ\n\nグラフを編集して両方の表現の変化を確認しましょう！',
      sceneConfig: { showGrid: true, showAxes: true, cameraPosition: [0, 0, 5] },
      interactive: true,
      nextCondition: 'click',
      stepType: 'interactive',
    },
  ],
};
