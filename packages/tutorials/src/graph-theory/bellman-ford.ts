import { Tutorial } from '../types';

export const bellmanFordTutorial: Tutorial = {
  id: 'bellman-ford',
  title: 'ベルマン・フォード法',
  description: '負の重みを含むグラフの最短経路を求めるアルゴリズムを学びます。',
  category: 'graph-theory',
  steps: [
    {
      id: 'hook',
      title: '負の重みへの対処',
      content: 'ダイクストラ法は負の重みを扱えません。\n\nベルマン・フォード法なら、負の重みがあっても最短経路を求められます。\n\n負の辺を含むグラフで最短経路が更新される様子を見てみましょう。',
      sceneConfig: { showGrid: true, showAxes: true, cameraPosition: [0, 0, 5] },
      customScene: 'bellman-ford-animation',
      interactive: false,
      nextCondition: 'click',
      stepType: 'animation',
    },
    {
      id: 'touch',
      title: '緩和を繰り返そう',
      content: 'すべての辺について「緩和」操作を繰り返してみましょう。\n\nd[v] > d[u] + w(u,v) なら d[v] を更新します。\n\nn-1回の繰り返しで最短距離が確定します。',
      sceneConfig: { showGrid: true, showAxes: true, cameraPosition: [0, 0, 5] },
      customScene: 'bellman-ford-interactive',
      interactive: true,
      nextCondition: 'interaction',
      stepType: 'interactive',
    },
    {
      id: 'example-1',
      title: 'アルゴリズムの手順',
      content: 'ベルマン・フォード法：\n\n1. d[s]=0、他は∞で初期化\n2. n-1回繰り返し：すべての辺(u,v)について d[v] = min(d[v], d[u]+w(u,v))\n3. もう1回チェックして更新があれば負閉路が存在\n\n計算量：O(VE)',
      sceneConfig: { showGrid: true, showAxes: true, cameraPosition: [0, 0, 5] },
      interactive: false,
      nextCondition: 'click',
      stepType: 'explanation',
    },
    {
      id: 'example-2',
      title: '負閉路の検出',
      content: 'ベルマン・フォード法の重要な副産物：負閉路の検出\n\nn-1回の繰り返し後にさらに緩和可能な辺があれば、その辺は負閉路上にあります。\n\n負閉路がある場合、最短経路は「-∞」になります（閉路を回り続けて距離を減らせるため）。',
      sceneConfig: { showGrid: true, showAxes: true, cameraPosition: [0, 0, 5] },
      interactive: false,
      nextCondition: 'click',
      stepType: 'explanation',
    },
    {
      id: 'predict',
      title: '確認クイズ',
      content: 'クイズに答えましょう。',
      sceneConfig: { showGrid: true, showAxes: true, cameraPosition: [0, 0, 5] },
      interactive: false,
      nextCondition: 'click',
      stepType: 'quiz',
      quiz: {
        question: 'ベルマン・フォード法の計算量はどれですか？',
        options: [
          { id: 'a', label: 'O(V log V)', correct: false },
          { id: 'b', label: 'O(V + E)', correct: false },
          { id: 'c', label: 'O(VE)', correct: true },
          { id: 'd', label: 'O(V²E)', correct: false },
        ],
        explanation: 'ベルマン・フォード法は V-1 回のループでそれぞれ E 本の辺をチェックするため、O(VE) です。',
      },
    },
    {
      id: 'alternate',
      title: 'SPFA（Shortest Path Faster Algorithm）',
      content: 'ベルマン・フォード法の実用的な改良として SPFA があります。\n\nキューを使って、距離が更新された頂点の辺のみを再チェックします。\n\n平均的には O(E) 程度で動作しますが、最悪ケースは O(VE) のままです。',
      sceneConfig: { showGrid: true, showAxes: true, cameraPosition: [0, 0, 5] },
      interactive: false,
      nextCondition: 'click',
      stepType: 'explanation',
    },
    {
      id: 'summary',
      title: 'まとめ',
      content: '今回学んだポイント：\n\n1. ベルマン・フォード法は負の重みに対応\n2. n-1回の緩和で最短距離が確定\n3. 負閉路の検出にも使える\n\n緩和の過程を操作して確認しましょう！',
      sceneConfig: { showGrid: true, showAxes: true, cameraPosition: [0, 0, 5] },
      customScene: 'bellman-ford-summary',
      interactive: true,
      nextCondition: 'click',
      stepType: 'interactive',
    },
  ],
};
